#include <iostream>
#include <vector>

using namespace std;

//63. 不同路径 II
class UniquePaths2 {
    /*
    一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
    现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
    网格中的障碍物和空位置分别用 1 和 0 来表示。

    输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
    输出：2
    解释：
    3x3 网格的正中间有一个障碍物。
    从左上角到右下角一共有 2 条不同的路径：
    1. 向右 -> 向右 -> 向下 -> 向下
    2. 向下 -> 向下 -> 向右 -> 向右

    输入：obstacleGrid = [[0,1],[0,0]]
    输出：1
     
    提示：
    m == obstacleGrid.length
    n == obstacleGrid[i].length
    1 <= m, n <= 100
    obstacleGrid[i][j] 为 0 或 1
    */
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid.empty())
            return 0;
        int c = obstacleGrid.size() - 1;
        int r = obstacleGrid[0].size() - 1;
        return add(obstacleGrid, c, r);
    }
private:
    int add(vector<vector<int>>& obstacleGrid, int i, int j) {
        /*
            递归 f(n,n)=f(n-1,n)+f(n,n-1)
            如果n,n是障碍点 f(n,n)=0

            该方法能解 但是性能会超时
        */
        if (obstacleGrid[i][j] == 1)
            return 0;   //不能到达
        if (i == 0 && j == 0)
            return 1;   //这里必须要循环到 ij 都为0，不能其中一个为0 因为可能中间有障碍点
        int ret = 0;
        if (i > 0) {
            ret += add(obstacleGrid, i - 1, j);
        }
        if (j > 0) {
            ret += add(obstacleGrid, i, j - 1);
        }
        return ret;
    }
public:
    int uniquePathsWithObstacles2(vector<vector<int>>& obstacleGrid) {
        //这是上面方法的改良版本 通过双循环替代递归 可大大提高性能
        //缺点是需要开辟一个nxn的dp空间存储中间过程
        if (obstacleGrid.empty())
            return 0;
        if (obstacleGrid[0][0] == 1)
            return 0;
        int c = obstacleGrid.size();
        int r = obstacleGrid[0].size();
        vector<vector<int>> dp(c, vector<int>(r, 0));
        int i = 0, j = 0;
        dp[0][0] = 1;
        for (int i = 0; i < c;++i) {
            for (int j = 0; j < r;++j) {
                if (i == 0 && j == 0)
                    continue;
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                    continue;
                }
                int add = 0;
                if (i > 0)
                    add += dp[i - 1][j];
                if (j > 0)
                    add += dp[i][j - 1];
                dp[i][j] = add;
            }
        }
        return dp[c - 1][r - 1];
    }
};

int main(int argc, char const* argv[])
{
    UniquePaths2 cls;
    vector<vector<int>> obj3{
        {0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0},
        {1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1},
        {0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0},
        {0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0},
        {0,0,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
        {0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0},
        {1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0},
        {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0},
        {1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1},
        {0,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0},
        {0,0,1,1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
        {0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0},
        {0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},
        {0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0},
        {0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0},
        {0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1},
        {0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1,0},
        {0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1},
        {0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,0},
        {0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0},
        {0,0,0,0,1,1,0,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1},
        {0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0},
        {0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},
        {0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0}
    };
    cout << cls.uniquePathsWithObstacles2(obj3) << " -> 2768280" << endl;
    vector<vector<int>> obj2{
        {1,0}
    };
    cout << cls.uniquePathsWithObstacles2(obj2) << " -> 0" << endl;
    vector<vector<int>> obj{
        {0,1},{0,0}
    };
    cout << cls.uniquePathsWithObstacles2(obj) << " -> 1" << endl;
    vector<vector<int>> obj1{
        {0,0,0},{0,1,0},{0,0,0}
    };
    cout << cls.uniquePathsWithObstacles2(obj1) << " -> 2" << endl;
    return 0;
}
